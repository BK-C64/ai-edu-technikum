<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Prototype</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="game-container">
        <div class="crosshair"></div>
    </div>

    <!-- Three.js Core Library (r160) - UMD Build -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <!-- Three.js PointerLockControls - Will implement manually below -->
    <script>
        // PointerLockControls implementation for UMD (no module system)
        // Based on Three.js r160 PointerLockControls
        THREE.PointerLockControls = function(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.isLocked = false;

            const scope = this;
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            const PI_2 = Math.PI / 2;

            // Event listeners support
            const listeners = {};

            function onMouseMove(event) {
                if (scope.isLocked === false) return;
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }

            function onPointerlockChange() {
                if (document.pointerLockElement === domElement) {
                    scope.isLocked = true;
                    scope.dispatchEvent({ type: 'lock' });
                } else {
                    scope.isLocked = false;
                    scope.dispatchEvent({ type: 'unlock' });
                }
            }

            function onPointerlockError() {
                console.error('PointerLockControls: Unable to use Pointer Lock API');
            }

            this.connect = function() {
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('pointerlockchange', onPointerlockChange);
                document.addEventListener('pointerlockerror', onPointerlockError);
            };

            this.disconnect = function() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('pointerlockchange', onPointerlockChange);
                document.removeEventListener('pointerlockerror', onPointerlockError);
            };

            this.lock = function() {
                this.domElement.requestPointerLock();
            };

            this.unlock = function() {
                document.exitPointerLock();
            };

            this.getDirection = (function() {
                const direction = new THREE.Vector3(0, 0, -1);
                return function(v) {
                    return v.copy(direction).applyQuaternion(camera.quaternion);
                };
            })();

            this.moveForward = function(distance) {
                const vec = new THREE.Vector3();
                vec.setFromMatrixColumn(camera.matrix, 0);
                vec.crossVectors(camera.up, vec);
                camera.position.addScaledVector(vec, distance);
            };

            this.moveRight = function(distance) {
                const vec = new THREE.Vector3();
                vec.setFromMatrixColumn(camera.matrix, 0);
                camera.position.addScaledVector(vec, distance);
            };

            // Event system
            this.addEventListener = function(type, listener) {
                if (!listeners[type]) listeners[type] = [];
                if (listeners[type].indexOf(listener) === -1) {
                    listeners[type].push(listener);
                }
            };

            this.removeEventListener = function(type, listener) {
                if (!listeners[type]) return;
                const index = listeners[type].indexOf(listener);
                if (index !== -1) {
                    listeners[type].splice(index, 1);
                }
            };

            this.dispatchEvent = function(event) {
                if (!listeners[event.type]) return;
                const array = listeners[event.type].slice();
                for (let i = 0; i < array.length; i++) {
                    array[i].call(this, event);
                }
            };

            this.connect();
        };
    </script>

    <!-- Game Scripts (Loaded in dependency order per architecture.md Section 4.4) -->
    <!-- World Layer -->
    <script src="js/world/Chunk.js"></script>
    <script src="js/world/VoxelWorld.js"></script>
    <script src="js/world/TerrainGenerator.js"></script>
    <script src="js/world/ChunkManager.js"></script>

    <!-- Rendering Layer -->
    <script src="js/rendering/TextureAtlasGenerator.js"></script>
    <script src="js/rendering/TextureManager.js"></script>
    <script src="js/rendering/MeshBuilder.js"></script>

    <!-- Physics Layer -->
    <script src="js/physics/Collision.js"></script>

    <!-- Input Layer -->
    <script src="js/input/InputHandler.js"></script>
    <script src="js/input/Controls.js"></script>

    <!-- Utils Layer -->
    <script src="js/utils/Raycaster.js"></script>

    <!-- Main Game Loop (must be last) -->
    <script src="js/main.js"></script>
</body>
</html>
